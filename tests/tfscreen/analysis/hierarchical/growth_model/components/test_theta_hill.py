import pytest
import jax.numpy as jnp
import numpyro.distributions as dist
from numpyro.handlers import trace, substitute, seed
from collections import namedtuple

# --- Import Module Under Test (MUT) ---
from tfscreen.analysis.hierarchical.growth_model.components.theta_hill import (
    ModelPriors,
    ThetaParam,
    define_model,
    guide,
    run_model,
    get_hyperparameters,
    get_guesses,
    get_priors
)

# --- Mock Data Fixture ---

MockDataClass = namedtuple("MockDataClass", [
    "num_titrant_name",
    "num_titrant_conc",
    "num_genotype",
    "batch_size",
    "batch_idx",
    "scale_vector",
    "log_titrant_conc",
    "geno_theta_idx",
    "scatter_theta"
])

@pytest.fixture
def mock_data():
    """
    Provides a mock data object for testing.
    - 2 titrant names
    - 3 titrant concentrations
    - 3 genotypes
    - Batch size 3 (Full batch for simplicity in basic tests)
    """
    num_titrant_name = 2
    num_titrant_conc = 3
    num_genotype = 3
    
    batch_size = 3
    batch_idx = jnp.arange(batch_size, dtype=jnp.int32)
    scale_vector = jnp.ones(batch_size, dtype=float)
    
    # log_titrant_conc: 1D array of shape (C,)
    # This allows data.log_titrant_conc[None,:,None] -> (1, C, 1)
    # which broadcasts with params (N, 1, G) -> (N, C, G)
    log_titrant_conc = jnp.linspace(-5, 5, num_titrant_conc)
    
    # geno_theta_idx: Maps calculation indices to parameter indices
    # For full batch, it's just 0..G-1
    geno_theta_idx = jnp.arange(num_genotype, dtype=jnp.int32)
    
    return MockDataClass(
        num_titrant_name=num_titrant_name,
        num_titrant_conc=num_titrant_conc,
        num_genotype=num_genotype,
        batch_size=batch_size,
        batch_idx=batch_idx,
        scale_vector=scale_vector,
        log_titrant_conc=log_titrant_conc,
        geno_theta_idx=geno_theta_idx,
        scatter_theta=1
    )

@pytest.fixture
def theta_param_setup(mock_data):
    """
    Returns a ThetaParam object generated by running define_model
    with specific guesses (zeros) for deterministic output.
    """
    name = "test_hill"
    priors = get_priors()
    
    # Get guesses and slice them for the batch
    base_guesses = get_guesses(name, mock_data)
    batch_guesses = base_guesses.copy()
    
    # The guesses are (Name, Genotype). Slice last dim.
    for k in batch_guesses:
        if "offset" in k:
            batch_guesses[k] = batch_guesses[k][..., mock_data.batch_idx]

    substituted_model = substitute(define_model, data=batch_guesses)
    theta_param = substituted_model(name=name,
                                    data=mock_data,
                                    priors=priors)
    return theta_param

# --- Test Cases ---

def test_get_hyperparameters():
    """Tests that get_hyperparameters returns the correct structure."""
    params = get_hyperparameters()
    assert isinstance(params, dict)
    assert "theta_logit_low_hyper_loc_loc" in params
    assert params["theta_logit_low_hyper_loc_loc"] == 2.0

def test_get_priors():
    """Tests that get_priors returns a correctly populated ModelPriors object."""
    priors = get_priors()
    assert isinstance(priors, ModelPriors)
    assert priors.theta_logit_low_hyper_loc_loc == 2.0

def test_get_guesses(mock_data):
    """Tests that get_guesses returns correctly named and shaped guesses."""
    name = "test_hill"
    guesses = get_guesses(name, mock_data)
    
    assert isinstance(guesses, dict)
    
    # Check shape of offsets: (Name, Genotype)
    expected_shape = (mock_data.num_titrant_name, mock_data.num_genotype)
    
    assert guesses[f"{name}_logit_low_offset"].shape == expected_shape
    assert guesses[f"{name}_log_hill_K_offset"].shape == expected_shape
    assert jnp.all(guesses[f"{name}_log_hill_K_offset"] == 0.0)

def test_define_model_shapes_and_values(mock_data):
    """
    Tests define_model output shapes and values using zero-offset guesses.
    """
    name = "test_hill"
    priors = get_priors()
    
    # Prepare batched guesses
    base_guesses = get_guesses(name, mock_data)
    batch_guesses = base_guesses.copy()
    for k in batch_guesses:
        if "offset" in k:
            batch_guesses[k] = batch_guesses[k][..., mock_data.batch_idx]

    substituted_model = substitute(define_model, data=batch_guesses)
    
    # --- Execute ---
    theta_param = substituted_model(name=name,
                                    data=mock_data,
                                    priors=priors)
    
    # --- Check Shape (Name, Batch) ---
    expected_shape = (mock_data.num_titrant_name, mock_data.batch_size)
    assert theta_param.theta_low.shape == expected_shape
    assert theta_param.log_hill_K.shape == expected_shape
    
    # --- Check Values ---
    # logit_low = hyper_loc + 0 = 2.0. theta_low = sigmoid(2.0) ~= 0.88
    # log_K = hyper_loc + 0 = -4.1.
    assert jnp.allclose(theta_param.log_hill_K, -4.1)

def test_run_model_calculation(mock_data):
    """
    Strict calculation test.
    We inject known parameters and concentrations and verify the Hill equation result.
    """
    # Create manual ThetaParam (All scalars broadcasted to shape)
    # Shape: (Name, Genotype) = (2, 3)
    shape = (mock_data.num_titrant_name, mock_data.num_genotype)
    
    # Define parameters
    theta_low = jnp.zeros(shape)       # Baseline 0
    theta_high = jnp.ones(shape)       # Max 1
    log_hill_K = jnp.zeros(shape)      # K = 1.0 (ln(1)=0)
    hill_n = jnp.ones(shape)           # n = 1
    
    theta_param = ThetaParam(theta_low, theta_high, log_hill_K, hill_n)

    # Setup specific concentrations to test K
    # mock_data.log_titrant_conc is (C,). We'll set the middle one to 0.0 (== log_K)
    # The inputs correspond to C=0, C=1, C=2
    # C=1 -> 0.0 (at K) -> expected theta 0.5
    new_concs = jnp.array([-10.0, 0.0, 10.0])
    mock_data = mock_data._replace(log_titrant_conc=new_concs, scatter_theta=0)
    
    # --- Run Calculation ---
    result = run_model(theta_param, mock_data)
    
    # Result shape: (Name, Conc, Genotype) -> (2, 3, 3)
    
    # Check C=0 (Very low conc -> theta close to theta_low=0)
    assert jnp.allclose(result[:, 0, :], 0.0, atol=1e-3)
    
    # Check C=1 (Conc == K -> theta = 0.5)
    assert jnp.allclose(result[:, 1, :], 0.5)
    
    # Check C=2 (Very high conc -> theta close to theta_high=1)
    assert jnp.allclose(result[:, 2, :], 1.0, atol=1e-3)

def test_run_model_scatter(theta_param_setup, mock_data):
    """
    Test that the scatter functionality reshapes the output correctly.
    """
    theta_param = theta_param_setup
    
    # Enable scatter
    data = mock_data._replace(scatter_theta=1)
    
    result = run_model(theta_param, data)
    
    # Expected shape: (1, 1, 1, 1, Name, Conc, Batch)
    expected_shape = (1, 1, 1, 1, 
                      mock_data.num_titrant_name, 
                      mock_data.num_titrant_conc, 
                      mock_data.batch_size)
    
    assert result.shape == expected_shape

def test_guide_logic_and_shapes(mock_data):
    """
    Tests the guide function shapes, parameter creation, and execution.
    """
    name = "test_hill_guide"
    priors = get_priors()

    with seed(rng_seed=0):
        guide_trace = trace(guide).get_trace(
            name=name,
            data=mock_data,
            priors=priors
        )
        theta_param = guide(name=name,
                            data=mock_data,
                            priors=priors)

    # --- 1. Check Parameter Sites (Global Genotype Shape) ---
    # Guide creates variational params for *all* genotypes
    assert f"{name}_logit_low_offset_locs" in guide_trace
    offset_locs = guide_trace[f"{name}_logit_low_offset_locs"]["value"]
    
    expected_param_shape = (mock_data.num_titrant_name, mock_data.num_genotype)
    assert offset_locs.shape == expected_param_shape

    # --- 2. Check Sample Sites (Batched Shape) ---
    # Sampling uses batch_idx to slice
    assert f"{name}_logit_low_offset" in guide_trace
    sampled_offsets = guide_trace[f"{name}_logit_low_offset"]["value"]
    
    expected_batch_shape = (mock_data.num_titrant_name, mock_data.batch_size)
    assert sampled_offsets.shape == expected_batch_shape

    # --- 3. Check Return Shape ---
    assert theta_param.theta_low.shape == expected_batch_shape